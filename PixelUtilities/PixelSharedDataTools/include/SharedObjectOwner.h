#ifndef SHAREDOBJECTOWNER_H_
#define SHAREDOBJECTOWNER_H_

//core imports
#include <set>
#include <map>
#include <pthread.h>

//local imports
#include "SharedObject.h"
#include "ObjectUpdateListener.h"
#include "ObjectUpdateEvent.h"

namespace pixel
{

/** \brief A class for serializing access to SharedObjects
 * 
 * The SharedObjectOwner exists to control access to a
 * SharedObject in a thread-safe, event driven manner.
 * THe companion classes to this class are the 
 * pixel::ObjectUpdateListener and the pixel::ObjectUpdateEvent.
 * <br/>
 * You use this class like so:
 * 
 * <pre>
 * pixel::SharedObject<MyClass>* obj1 = new pixel::SharedObject<MyClass>("MyClassObject");
 * pixel::SharedObjectOwner<MyClass) owner(obj1);
 * ...add code to add listeners to the events the owner will put out here...
 * owner.fireObjectUpdateEvent("MyClassObject");
 * </pre>
 * In general, this class is most useful as a static object in a class that
 * is acquiring data that more than one thread would like to use.  The addObjectUpdateListener()
 * method is thread-safe, and, in fact, the class as a whole is thread safe.  As long as you
 * only use this class to access SharedObjects, you will not have to worry about
 * corrupted SharedObjects.  
 * <br/>
 * The SharedObjectOwner is the owner of the SharedObjects in the sense that when
 * removeSharedObject() or the destructor are called, the SharedObjects are released.
 * <br/>
 * See pixel::ObjectUpdateListener for the interface that allows for the callback methods
 * to be used with this class.
 * 
 * 
 */
template <class T>
class SharedObjectOwner
{
public:
	
	//! Constructs a new SharedObjectOwner
	SharedObjectOwner();
	SharedObjectOwner(pixel::SharedObject<T>* object);
	virtual ~SharedObjectOwner();
	
	//! returns the set of shared objects associated with this SharedObjectOwner
	inline std::set<pixel::SharedObject<T>* > getSharedObjects() {return objects_;}
	
	//! Associates another shared object with this SharedObjectOwner
	void addSharedObject(pixel::SharedObject<T>* object);
	
	//! Disassociates the specified shared object with this owner, and deletes the object
	void removeSharedObject(pixel::SharedObject<T>* object);
	
	//! Gets a shared object by the specified name (even if it doesn't belong to this SharedObjectOwner!)
	pixel::SharedObject<T>* getSharedObject(std::string name); 
	
	//! Runs the callback method on all pixel::ObjectUpdateListeners registered to the named object 
	void fireObjectUpdateEvent(std::string updatedObject);
	
	//! Adds a new pixel::ObjectUpdateListener to listen to events generated by this SharedObjectOwner
	void addObjectUpdateListener(std::string object, pixel::ObjectUpdateListener<T>* listener);
	
	//! Removes the listener from the notification queue, and deletes it (as in releases the storage for it)
	void removeObjectUpdateListener(std::string object, pixel::ObjectUpdateListener<T>* listener);
	
	inline unsigned int numListeners(std::string id) {return listeners_[id].size();}
	
private:
	//pixel::SharedObject<T>* object_;
	std::set<pixel::SharedObject<T>* > objects_;
	std::map<std::string, std::set<pixel::ObjectUpdateListener<T>* > > listeners_;
	pthread_mutex_t listenerMutex;
	pthread_mutex_t objectMutex;
};

template <class T>
SharedObjectOwner<T>::SharedObjectOwner() {

}

template <class T>
SharedObjectOwner<T>::SharedObjectOwner(pixel::SharedObject<T>* object)
{
	pthread_mutex_init(&listenerMutex, 0);
	pthread_mutex_init(&objectMutex, 0);
	objects_.insert(object);
}

template <class T>
SharedObjectOwner<T>::~SharedObjectOwner()
{
		//Remove and delete all the listeners
		typename std::map<std::string, std::set<pixel::ObjectUpdateListener<T>* > >::iterator allListeners;
		typename std::set<pixel::ObjectUpdateListener<T>* >::iterator listeners;
		for(allListeners = listeners_.begin(); allListeners!= listeners_.end(); allListeners++) {
			for(listeners = (*allListeners).second.begin();listeners != (*allListeners).second.end();listeners++) {
				removeObjectUpdateListener((*allListeners).first, (*listeners));
			}
		}
		
		//Release storage for all the objects
		typename std::set<pixel::SharedObject<T>* >::iterator objects;
		for(objects = objects_.begin(); objects!= objects_.end(); objects++) {
			(*objects)->release();
		
			delete (*objects);
		}
		
		//kill out the mutexes
		pthread_mutex_destroy(&listenerMutex);
		pthread_mutex_destroy(&objectMutex);
}

template <class T>
void SharedObjectOwner<T>::addSharedObject(pixel::SharedObject<T>* object) {
	pthread_mutex_lock(&objectMutex);
	objects_.insert(object);
	pthread_mutex_unlock(&objectMutex);
}

template <class T>
void SharedObjectOwner<T>::removeSharedObject(pixel::SharedObject<T>* object) {
	pthread_mutex_lock(&objectMutex);
	listeners_[object->getName].clear();
	objects_.erase(object);
	object->release();
	pthread_mutex_unlock(&objectMutex);
}

template <class T>
void SharedObjectOwner<T>::fireObjectUpdateEvent(std::string objectName) {
	typename std::set<pixel::ObjectUpdateListener<T>* >::iterator it;
	typename std::set<pixel::SharedObject<T>* >::iterator objects;
	std::set<pixel::ObjectUpdateListener<T>* > listeners = listeners_[objectName];	
	
	//Look to see if the object belongs to this SharedObjectOwner
	//If not, don't do anything
	pixel::SharedObject<T>* object = 0;
	bool found = false;
	pthread_mutex_lock(&objectMutex);
	
	for(objects = objects_.begin();objects!=objects_.end();objects++) {
		if((*objects)->getName().compare(objectName)==0) {
			object = (*objects);
			found = true;
			break;
		}
	}
	pthread_mutex_unlock(&objectMutex);
	
	//If not found
	if(found) {

		pixel::ObjectUpdateEvent<T> e(object, this);
		//std::cout << "Firing event for " << listeners.size() << " listeners" << std::endl;
		pthread_mutex_lock(&listenerMutex);
		for(it = listeners.begin(); it!=listeners.end(); it++) {
			(*it)->actionPerformed(e);
			//std::cout << "Fired Event" << std::endl;
		}
		pthread_mutex_unlock(&listenerMutex);
	}

}

template <class T>
void SharedObjectOwner<T>::addObjectUpdateListener(std::string objectName, pixel::ObjectUpdateListener<T>* listener){
	pthread_mutex_lock(&listenerMutex);
	listeners_[objectName].insert(listener);
	pthread_mutex_unlock(&listenerMutex); 
}

template <class T>
void SharedObjectOwner<T>::removeObjectUpdateListener(std::string objectName, pixel::ObjectUpdateListener<T>* listener){
	pthread_mutex_lock(&listenerMutex);
	listeners_[objectName].erase(listener);
	pthread_mutex_unlock(&listenerMutex);
	delete listener;
}

template <class T>
pixel::SharedObject<T>* SharedObjectOwner<T>::getSharedObject(std::string name) {
	
	//Look for the object and return it if found... if not, make a new one and return it
	typename std::set<pixel::SharedObject<T>* >::iterator it;
	pixel::SharedObject<T>* obj = 0;
	bool found = false;
	for(it = objects_.begin();it!=objects_.end();it++) {
		if((*it)->getName().compare(name)==0) {
			obj =  (*it);
			found = true;
			break;
		}
	}
	if(found)
		return obj;
	else {
		pixel::SharedObject<T>* newObj = new pixel::SharedObject<T>(name);
		addSharedObject(newObj);
		return newObj;
	}
	
}


}

//source the rest of the template definitions
//#include "../src/common/SharedObjectOwner.inl"
#endif /*SHAREDOBJECTOWNER_H_*/
